
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Bitsets &mdash; LLVM 3.9 documentation</title>
    
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="LLVM 3.9 documentation" href="index.html" />
    <link rel="next" title="FaultMaps and implicit checks" href="FaultMaps.html" />
    <link rel="prev" title="MergeFunctions pass, how it works" href="MergeFunctions.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head>
  <body role="document">
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="FaultMaps.html" title="FaultMaps and implicit checks"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="MergeFunctions.html" title="MergeFunctions pass, how it works"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="bitsets">
<h1>Bitsets<a class="headerlink" href="#bitsets" title="Permalink to this headline">¶</a></h1>
<p>This is a mechanism that allows IR modules to co-operatively build pointer
sets corresponding to addresses within a given set of globals. One example
of a use case for this is to allow a C++ program to efficiently verify (at
each call site) that a vtable pointer is in the set of valid vtable pointers
for the type of the class or its derived classes.</p>
<p>To use the mechanism, a client creates a global metadata node named
<code class="docutils literal"><span class="pre">llvm.bitsets</span></code>.  Each element is a metadata node with three elements:</p>
<ol class="arabic simple">
<li>a metadata object representing an identifier for the bitset</li>
<li>either a global variable or a function</li>
<li>a byte offset into the global (generally zero for functions)</li>
</ol>
<p>Each bitset must exclusively contain either global variables or functions.</p>
<div class="admonition-limitation admonition">
<p class="first admonition-title">Limitation</p>
<p class="last">The current implementation only supports functions as members of bitsets on
the x86-32 and x86-64 architectures.</p>
</div>
<p>An intrinsic, <a class="reference internal" href="LangRef.html#bitset-test"><span>llvm.bitset.test</span></a>, is used to test
whether a given pointer is a member of a bitset.</p>
<div class="section" id="representing-type-information-using-bitsets">
<h2>Representing Type Information using Bitsets<a class="headerlink" href="#representing-type-information-using-bitsets" title="Permalink to this headline">¶</a></h2>
<p>This section describes how Clang represents C++ type information associated with
virtual tables using bitsets.</p>
<p>Consider the following inheritance hierarchy:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">B</span> <span class="p">:</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">g</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">C</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">h</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">D</span> <span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">C</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">h</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The virtual table objects for A, B, C and D look like this (under the Itanium ABI):</p>
<table border="1" class="docutils" id="id1">
<caption><span class="caption-text">Virtual Table Layout for A, B, C, D</span><a class="headerlink" href="#id1" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Class</th>
<th class="head">0</th>
<th class="head">1</th>
<th class="head">2</th>
<th class="head">3</th>
<th class="head">4</th>
<th class="head">5</th>
<th class="head">6</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>A</td>
<td>A::offset-to-top</td>
<td>&amp;A::rtti</td>
<td>&amp;A::f</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>B</td>
<td>B::offset-to-top</td>
<td>&amp;B::rtti</td>
<td>&amp;B::f</td>
<td>&amp;B::g</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>C</td>
<td>C::offset-to-top</td>
<td>&amp;C::rtti</td>
<td>&amp;C::h</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>D</td>
<td>D::offset-to-top</td>
<td>&amp;D::rtti</td>
<td>&amp;D::f</td>
<td>&amp;D::h</td>
<td>D::offset-to-top</td>
<td>&amp;D::rtti</td>
<td>thunk for &amp;D::h</td>
</tr>
</tbody>
</table>
<p>When an object of type A is constructed, the address of <code class="docutils literal"><span class="pre">&amp;A::f</span></code> in A&#8217;s
virtual table object is stored in the object&#8217;s vtable pointer.  In ABI parlance
this address is known as an <a class="reference external" href="https://mentorembedded.github.io/cxx-abi/abi.html#vtable-general">address point</a>. Similarly, when an object of type
B is constructed, the address of <code class="docutils literal"><span class="pre">&amp;B::f</span></code> is stored in the vtable pointer. In
this way, the vtable in B&#8217;s virtual table object is compatible with A&#8217;s vtable.</p>
<p>D is a little more complicated, due to the use of multiple inheritance. Its
virtual table object contains two vtables, one compatible with A&#8217;s vtable and
the other compatible with C&#8217;s vtable. Objects of type D contain two virtual
pointers, one belonging to the A subobject and containing the address of
the vtable compatible with A&#8217;s vtable, and the other belonging to the C
subobject and containing the address of the vtable compatible with C&#8217;s vtable.</p>
<p>The full set of compatibility information for the above class hierarchy is
shown below. The following table shows the name of a class, the offset of an
address point within that class&#8217;s vtable and the name of one of the classes
with which that address point is compatible.</p>
<table border="1" class="docutils" id="id2">
<caption><span class="caption-text">Bitsets for A, B, C, D</span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">VTable for</th>
<th class="head">Offset</th>
<th class="head">Compatible Class</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>A</td>
<td>16</td>
<td>A</td>
</tr>
<tr class="row-odd"><td>B</td>
<td>16</td>
<td>A</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>B</td>
</tr>
<tr class="row-odd"><td>C</td>
<td>16</td>
<td>C</td>
</tr>
<tr class="row-even"><td>D</td>
<td>16</td>
<td>A</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>D</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>48</td>
<td>C</td>
</tr>
</tbody>
</table>
<p>The next step is to encode this compatibility information into the IR. The way
this is done is to create bitsets named after each of the compatible classes,
into which we add each of the compatible address points in each vtable.
For example, these bitset entries encode the compatibility information for
the above hierarchy:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>!0 = !{!&quot;_ZTS1A&quot;, [3 x i8*]* @_ZTV1A, i64 16}
!1 = !{!&quot;_ZTS1A&quot;, [4 x i8*]* @_ZTV1B, i64 16}
!2 = !{!&quot;_ZTS1B&quot;, [4 x i8*]* @_ZTV1B, i64 16}
!3 = !{!&quot;_ZTS1C&quot;, [3 x i8*]* @_ZTV1C, i64 16}
!4 = !{!&quot;_ZTS1A&quot;, [7 x i8*]* @_ZTV1D, i64 16}
!5 = !{!&quot;_ZTS1D&quot;, [7 x i8*]* @_ZTV1D, i64 16}
!6 = !{!&quot;_ZTS1C&quot;, [7 x i8*]* @_ZTV1D, i64 48}
</pre></div>
</div>
<p>With these bitsets, we can now use the <code class="docutils literal"><span class="pre">llvm.bitset.test</span></code> intrinsic to test
whether a given pointer is compatible with a bitset. Working backwards,
if <code class="docutils literal"><span class="pre">llvm.bitset.test</span></code> returns true for a particular pointer, we can also
statically determine the identities of the virtual functions that a particular
virtual call may call. For example, if a program assumes a pointer to be in the
<code class="docutils literal"><span class="pre">!&quot;_ZST1A&quot;</span></code> bitset, we know that the address can be only be one of <code class="docutils literal"><span class="pre">_ZTV1A+16</span></code>,
<code class="docutils literal"><span class="pre">_ZTV1B+16</span></code> or <code class="docutils literal"><span class="pre">_ZTV1D+16</span></code> (i.e. the address points of the vtables of A,
B and D respectively). If we then load an address from that pointer, we know
that the address can only be one of <code class="docutils literal"><span class="pre">&amp;A::f</span></code>, <code class="docutils literal"><span class="pre">&amp;B::f</span></code> or <code class="docutils literal"><span class="pre">&amp;D::f</span></code>.</p>
</div>
<div class="section" id="testing-bitset-addresses">
<h2>Testing Bitset Addresses<a class="headerlink" href="#testing-bitset-addresses" title="Permalink to this headline">¶</a></h2>
<p>If a program tests an address using <code class="docutils literal"><span class="pre">llvm.bitset.test</span></code>, this will cause
a link-time optimization pass, <code class="docutils literal"><span class="pre">LowerBitSets</span></code>, to replace calls to this
intrinsic with efficient code to perform bitset tests. At a high level,
the pass will lay out referenced globals in a consecutive memory region in
the object file, construct bit vectors that map onto that memory region,
and generate code at each of the <code class="docutils literal"><span class="pre">llvm.bitset.test</span></code> call sites to test
pointers against those bit vectors. Because of the layout manipulation, the
globals&#8217; definitions must be available at LTO time. For more information,
see the <a class="reference external" href="http://clang.llvm.org/docs/ControlFlowIntegrityDesign.html">control flow integrity design document</a>.</p>
<p>A bit set containing functions is transformed into a jump table, which is a
block of code consisting of one branch instruction for each of the functions
in the bit set that branches to the target function. The pass will redirect
any taken function addresses to the corresponding jump table entry. In the
object file&#8217;s symbol table, the jump table entries take the identities of
the original functions, so that addresses taken outside the module will pass
any verification done inside the module.</p>
<p>Jump tables may call external functions, so their definitions need not
be available at LTO time. Note that if an externally defined function is a
member of a bitset, there is no guarantee that its identity within the module
will be the same as its identity outside of the module, as the former will
be the jump table entry if a jump table is necessary.</p>
<p>The <a class="reference external" href="http://llvm.org/klaus/llvm/blob/master/include/llvm/Transforms/IPO/LowerBitSets.h">GlobalLayoutBuilder</a> class is responsible for laying out the globals
efficiently to minimize the sizes of the underlying bitsets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span></span>target datalayout = &quot;e-p:32:32&quot;

@a = internal global i32 0
@b = internal global i32 0
@c = internal global i32 0
@d = internal global [2 x i32] [i32 0, i32 0]

define void @e() {
  ret void
}

define void @f() {
  ret void
}

declare void @g()

!llvm.bitsets = !{!0, !1, !2, !3, !4, !5, !6}

!0 = !{!&quot;bitset1&quot;, i32* @a, i32 0}
!1 = !{!&quot;bitset1&quot;, i32* @b, i32 0}
!2 = !{!&quot;bitset2&quot;, i32* @b, i32 0}
!3 = !{!&quot;bitset2&quot;, i32* @c, i32 0}
!4 = !{!&quot;bitset2&quot;, i32* @d, i32 4}
!5 = !{!&quot;bitset3&quot;, void ()* @e, i32 0}
!6 = !{!&quot;bitset3&quot;, void ()* @g, i32 0}

declare i1 @llvm.bitset.test(i8* %ptr, metadata %bitset) nounwind readnone

define i1 @foo(i32* %p) {
  %pi8 = bitcast i32* %p to i8*
  %x = call i1 @llvm.bitset.test(i8* %pi8, metadata !&quot;bitset1&quot;)
  ret i1 %x
}

define i1 @bar(i32* %p) {
  %pi8 = bitcast i32* %p to i8*
  %x = call i1 @llvm.bitset.test(i8* %pi8, metadata !&quot;bitset2&quot;)
  ret i1 %x
}

define i1 @baz(void ()* %p) {
  %pi8 = bitcast void ()* %p to i8*
  %x = call i1 @llvm.bitset.test(i8* %pi8, metadata !&quot;bitset3&quot;)
  ret i1 %x
}

define void @main() {
  %a1 = call i1 @foo(i32* @a) ; returns 1
  %b1 = call i1 @foo(i32* @b) ; returns 1
  %c1 = call i1 @foo(i32* @c) ; returns 0
  %a2 = call i1 @bar(i32* @a) ; returns 0
  %b2 = call i1 @bar(i32* @b) ; returns 1
  %c2 = call i1 @bar(i32* @c) ; returns 1
  %d02 = call i1 @bar(i32* getelementptr ([2 x i32]* @d, i32 0, i32 0)) ; returns 0
  %d12 = call i1 @bar(i32* getelementptr ([2 x i32]* @d, i32 0, i32 1)) ; returns 1
  %e = call i1 @baz(void ()* @e) ; returns 1
  %f = call i1 @baz(void ()* @f) ; returns 0
  %g = call i1 @baz(void ()* @g) ; returns 1
  ret void
}
</pre></div>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="FaultMaps.html" title="FaultMaps and implicit checks"
             >next</a> |</li>
        <li class="right" >
          <a href="MergeFunctions.html" title="MergeFunctions pass, how it works"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2003-2016, LLVM Project.
      Last updated on 2016-03-10.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>